# 다형성과 추상화

## 다형성 (Polymorphism) - 여러 모습을 갖는것
- 객체지향에서는 한 객체가 여러가지 타입을 갖는 것
  - 한 객체가 여러 타입의 기능을 제공하는 것
  - 타입 상속으로 다형성을 구현함
    - 하위 타입은 상위 타입으로 변형도 됨


## 추상화(Abstraction)
- 데이터나 프로세스등을 의미가 비슷한 개념, 의미있는 표현으로 정의하는 과정
- 두 가지 방식의 추상화
  - 특정한 성질, 공통 성질(일반화)
- 간단한 예
  - DB 의 USER 테이블 : 아이디, 이름 이메일
  - Money 클래스 : 통화, 금액
  - 프린터 : 브랜드별
  - GPU : 브랜드별

### 서로 다른 구현의 추상화
- SCP 로 파일 업로드
- HTTP 로 데이터 전송
- DB 테이블에 삽입

-> 셋다 PUSH 를 구현한 것(PUSH 로 추상화 가능)


## 타입 추상화?
- 여러 구현 클래스를 대표하는 상위 타입을 도출함
  - 흔히 인터페이스 타입으로 추상화 한다.
    - 기능에 대한 의미 제공
    - 구현은 제공하지 않으므로 어떻게 구현할지 알 수 없음
  - 추상화 타입과 구현은 타입 상속으로 연결함
    - 상속하고 있는 클래스로 구현을 함 -> 콘크리트(Concrete) 클래스

### 추상 타입 사용
- 추상 타입을 이용한 프로그래밍
- Notifier 를 이용하며 notify 하는 경우
- 추상 타입은 구현을 감춘다.
  - 기능의 구현자체가 아닌 의도에 집중


### 추상 타입 사용의 이점
- 유연함
  - 콘크리트 클래스를 직접 사용할 경우?
    - 코드를 한눈에 알아보기 힘들정도로 복잡해짐
  - 사용할 대상의 접근까지도 추상화 가능(ex. NotifierFactory)
- NotifierFactory, Notifier 인터페이스가 변경될지라도 기능에 해당하는 OrderCancelService 는 변하지 않는다.


### 추상화는 의존 대상이 변경하는 시점에
- 추상화 -> 추상 타입 증가 -> 복잡도 증가
  - 아직 존재하지 않는 기능에 대한 이른 추상화는 주의해야함
    - 잘못된 추상화의 가능성이 있고, 코드의 복잡도만 증가할 수 있다.
    - 실제 변경 확장이 발생할 때 맞춰서 추상화를 시도하는 것이 좋다.


### 추상화를 잘 하기 위해서는?
- 구현을 하는 이유가 무엇 때문인지를 꼭 생각하자
- 추상화 대상의 공통점을 찾고,이에 맞추어 진행함


# 추상화를 하지 않을 경우?
- 코드 구조가 길어지고 복잡해짐
  - 새로운 타입의 추가시 모든 메서드에 if 블록이 추가될 수도 있음
    - 중첩 if-else : 복잡도 배로 증가, 개발 진척이 느려짐
- 관련 코드가 여러 곳에 분산되게됨
  - 코드 가독성 및 분석 속도 저하
  - 코드 추가에 따른 노동 시간이 증가함
  - 실수하기 쉽고, 이로인한 불필요한 디버깅 시간 증가


# OCP (Open-Closed Principle) 
- 기능의 변경 및 확장에는 열려 있으며, 해당 기능을 사용하는 수정은 하지 않아아 함(닫혀 있어야함)
- 추상화를 잘하면, OCP를 확장할 수 있는 가능성이 더 열리게 됨